import helmet from 'helmet';
import cors from 'cors';
import compression from 'compression';
import rateLimit from 'express-rate-limit';
import { ENV } from './environment.js';
import { ERRORS } from '../constants/errors.js';
import { logInfo, logError } from '../utils/logger.js';
import { HTTP_STATUS } from '../constants/httpStatus.js';
import { NotFoundError } from '../utils/appError.js';

// ================================================================
// UTILITAIRES INTERNES
// ================================================================

/**
 * Extrait l'IP réelle du client.
 * Indispensable pour les plateformes PaaS (Render, Heroku, Vercel) qui
 * placent l'app derrière un Load Balancer.
 *
 * @param {import('express').Request} req
 * @returns {string} L'adresse IP normalisée ou 'unknown'
 */
const getClientIp = (req) => {
    // x-forwarded-for contient la chaîne des IPs : "client, proxy1, proxy2"
    const forwardedFor = req.headers['x-forwarded-for'];
    if (forwardedFor) {
        return forwardedFor.split(',')[0].trim();
    }
    return req.ip || 'unknown';
};

/**
 * Définit les origines autorisées (CORS).
 * Sépare la logique de production et de développement.
 */
const getAllowedOrigins = () => {
    if (ENV.server.nodeEnv === 'production') {
        return ['https://fburger.vercel.app'];
    }
    return [
        'http://localhost:5173',
        'http://localhost:5174',
        'http://localhost:3000',
    ];
};

const origins = process.env.CORS_ORIGINS?.split(',') || getAllowedOrigins();

// ================================================================
// MIDDLEWARES DE SÉCURITÉ (GLOBAL)
// ================================================================

/**
 * Configuration Helmet : En-têtes de sécurité HTTP.
 * Définit la Content Security Policy (CSP) pour bloquer les scripts malveillants.
 */
export const helmetMiddleware = helmet({
    contentSecurityPolicy: {
        directives: {
            defaultSrc: ["'self'"],
            scriptSrc: ["'self'"],
            styleSrc: ["'self'", "'unsafe-inline'"], // unsafe-inline nécessaire pour certains styles dynamiques
            imgSrc: ["'self'", 'data:', 'blob:', 'https://res.cloudinary.com'],
            connectSrc: [
                "'self'",
                'https://ecom-watch-frontend.vercel.app',
                'https://votre-app-h1watch.onrender.com',
                'https://o4510681965199360.ingest.de.sentry.io',
            ],
            fontSrc: ["'self'", 'data:'],
            objectSrc: ["'none'"],
            mediaSrc: ["'self'"],
            frameSrc: ["'none'"],
            upgradeInsecureRequests: [],
        },
    },
    hsts: {
        maxAge: 31536000, // 1 an
        includeSubDomains: true,
        preload: true,
    },
});

/**
 * Configuration CORS : Cross-Origin Resource Sharing.
 * Vérifie strictement l'origine des requêtes.
 */
export const corsMiddleware = cors({
    origin: (origin, cb) => {
        // Autorise les requêtes sans origine (ex: Postman, App Mobile) ou listées
        const isAllowed = !origin || origins.some((allowedOrigin) =>
            allowedOrigin instanceof RegExp
                ? allowedOrigin.test(origin)
                : allowedOrigin === origin
        );

        return isAllowed
            ? cb(null, true)
            : cb(new Error(`Origine non autorisée par CORS : ${origin}`));
    },
    methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'],
    credentials: true, // Autorise les cookies/headers d'auth
});

/**
 * Compression GZIP.
 * Améliore la vitesse de réponse pour les clients compatibles.
 * Filtre personnalisé pour désactiver via header si besoin.
 */
export const compressResponse = compression({
    filter: (req, res) => {
        if (req.headers['x-no-compression']) return false;
        return compression.filter(req, res);
    },
    level: 6, // Bon compromis CPU / Taille
});

// ================================================================
// RATE LIMITERS (Stratégies anti-abus)
// ================================================================

/**
 * Limiteur Global.
 * Premier rempart contre le scraping massif et les attaques DDoS basiques.
 */
export const generalLimiter = rateLimit({
    windowMs: ENV.rateLimit.windowMs,
    max: ENV.rateLimit.max,
    validate: { ip: false },
    standardHeaders: true,
    legacyHeaders: false,
    keyGenerator: (req) => getClientIp(req),
});

/**
 * Limiteur Authentification (Login/Register).
 * Strict pour empêcher le Brute-Force sur les identifiants.
 */
export const authLimiter = rateLimit({
    windowMs: ENV.rateLimit.authWindowMs,
    max: ENV.rateLimit.authMax,
    validate: { ip: false },
    standardHeaders: true,
    legacyHeaders: false,
    keyGenerator: (req) => getClientIp(req),
    handler: (req, res) => {
        const clientIp = getClientIp(req);
        logInfo(`Tentative de spam détectée depuis l'IP : ${clientIp}`);
        res.status(HTTP_STATUS.TOO_MANY_REQUESTS).json({
            status: HTTP_STATUS.TOO_MANY_REQUESTS,
            error: ERRORS.AUTH.TOO_MANY_ATTEMPTS,
            message: 'Trop de tentatives, veuillez réessayer plus tard.',
        });
    },
});

/**
 * Limiteur Changement de Mot de Passe.
 * Critique : Protège contre le brute-force de l'ancien mot de passe.
 */
export const passwordChangeLimiter = rateLimit({
    windowMs: 15 * 60 * 1000,  // 15 minutes
    max: 3,                      // 3 tentatives max
    validate: { ip: false },
    standardHeaders: true,
    legacyHeaders: false,
    keyGenerator: (req) => `password-change:${getClientIp(req)}:${req.user?.id || 'anonymous'}`,

    handler: (req, res) => {
        const clientIp = getClientIp(req);
        const userId = req.user?.id || 'anonymous';

        // Log de la tentative bloquée (remplace onLimitReached)
        logInfo(`Rate limit changement MDP dépassé : IP=${clientIp}, User=${userId}`);

        res.status(HTTP_STATUS.TOO_MANY_REQUESTS).json({
            status: HTTP_STATUS.TOO_MANY_REQUESTS,
            error: 'TOO_MANY_ATTEMPTS',
            message: 'Trop de tentatives de changement de mot de passe. Veuillez réessayer dans 15 minutes.',
            retryAfter: '15 minutes'
        });
    }
});

/**
 * Limiteur Suivi de Commande Guest.
 * Protège contre l'énumération des IDs de commande.
 */
export const trackingGuestLimiter = rateLimit({
    windowMs: 15 * 60 * 1000,  // 15 minutes
    max: 5,                      // 5 tentatives max
    validate: { ip: false },
    standardHeaders: true,
    legacyHeaders: false,
    keyGenerator: (req) => `tracking-guest:${getClientIp(req)}`,

    handler: (req, res) => {
        const clientIp = getClientIp(req);

        // Log de la tentative bloquée (remplace onLimitReached)
        logInfo(`Rate limit suivi guest dépassé : IP=${clientIp}`);

        res.status(HTTP_STATUS.TOO_MANY_REQUESTS).json({
            status: HTTP_STATUS.TOO_MANY_REQUESTS,
            error: 'TOO_MANY_ATTEMPTS',
            message: 'Trop de tentatives de recherche. Veuillez réessayer dans 15 minutes.',
            retryAfter: '15 minutes'
        });
    }
});

/**
 * Limiteur Profil Utilisateur.
 * Plus permissif pour permettre la navigation normale / polling.
 */
export const profileGeneralLimiter = rateLimit({
    windowMs: 15 * 60 * 1000,  // 15 minutes
    max: 100,                    // 100 tentatives max
    validate: { ip: false },
    standardHeaders: true,
    legacyHeaders: false,
    keyGenerator: (req) => `profile-general:${getClientIp(req)}:${req.user?.id || 'anonymous'}`,

    handler: (req, res) => {
        const clientIp = getClientIp(req);
        const userId = req.user?.id || 'anonymous';

        logInfo(`Rate limit profil général dépassé : IP=${clientIp}, User=${userId}`);

        res.status(HTTP_STATUS.TOO_MANY_REQUESTS).json({
            status: HTTP_STATUS.TOO_MANY_REQUESTS,
            error: 'TOO_MANY_REQUESTS',
            message: 'Trop de requêtes. Veuillez réessayer dans 15 minutes.',
            retryAfter: '15 minutes'
        });
    }
});

/**
 * Limiteur Réinitialisation de Mot de Passe.
 * Strict pour prévenir l'abus d'envoi d'emails et le brute-force de tokens.
 * Clé par IP uniquement (pas d'userId car l'utilisateur est déconnecté).
 */
export const passwordResetLimiter = rateLimit({
    windowMs: 60 * 60 * 1000, // 1 heure
    max: 5,                     // 5 tentatives max (forgot + reset confondus)
    validate: { ip: false },
    standardHeaders: true,
    legacyHeaders: false,
    keyGenerator: (req) => `password-reset:${getClientIp(req)}`,

    handler: (req, res) => {
        const clientIp = getClientIp(req);
        logInfo(`Rate limit reset MDP dépassé : IP=${clientIp}`);

        res.status(HTTP_STATUS.TOO_MANY_REQUESTS).json({
            status: HTTP_STATUS.TOO_MANY_REQUESTS,
            error: 'TOO_MANY_ATTEMPTS',
            message: 'Trop de tentatives. Veuillez réessayer dans une heure.',
            retryAfter: '1 heure',
        });
    },
});

// ================================================================
// GESTION DES ERREURS
// ================================================================

/**
 * Middleware 404.
 * Intercepte toutes les requêtes qui n'ont pas trouvé de route correspondante.
 */
export const notFound = (req, _res, next) => {
    next(new NotFoundError('Route', req.originalUrl));
};