server {
    listen      ${PORT};
    server_name _;

    client_max_body_size 10M;

    # ── Supprime les headers CORS upstream pour éviter les doublons ──
    proxy_hide_header Access-Control-Allow-Origin;
    proxy_hide_header Access-Control-Allow-Credentials;
    proxy_hide_header Access-Control-Allow-Methods;
    proxy_hide_header Access-Control-Allow-Headers;
    proxy_hide_header Access-Control-Max-Age;

    # ── CORS headers gérés uniquement par le Gateway ─────────────────
    add_header Access-Control-Allow-Origin      $cors_origin always;
    add_header Access-Control-Allow-Credentials "true"       always;
    add_header Access-Control-Allow-Methods     "GET, POST, PUT, PATCH, DELETE, OPTIONS" always;
    add_header Access-Control-Allow-Headers     "Authorization, Content-Type, X-Request-ID" always;
    add_header Access-Control-Max-Age           "86400" always;
    add_header X-Gateway                        "ecom-watch" always;

    # ── Preflight OPTIONS ─────────────────────────────────────────────
    if ($request_method = OPTIONS) {
        return 204;
    }

    # ── Health check Gateway ──────────────────────────────────────────
    location = /health {
        access_log off;
        add_header Content-Type application/json;
        return 200 '{"status":"ok","service":"api-gateway","version":"1.0.0"}';
    }

    # ─────────────────────────────────────────────────────────────────
    # BLOCAGE DES ROUTES INTERNES
    # Les routes /internal/* ne sont jamais exposées à Internet.
    # Elles ne transitent qu'en réseau interne Render (service-to-service).
    # ─────────────────────────────────────────────────────────────────
    location ~ ^/internal/ {
        return 404;
    }

    # ─────────────────────────────────────────────────────────────────
    # AUTH-SERVICE — /auth/* et /users/*
    # ─────────────────────────────────────────────────────────────────

    # Rate limit strict sur les routes sensibles (login, register...)
    location ~ ^/(api/v1/)?auth/(login|register|forgot-password|reset-password) {
        limit_req zone=auth burst=5 nodelay;
        limit_req_status 429;
        include /tmp/nginx/conf.d/proxy_params.conf;
        proxy_pass https://auth_service;
        proxy_ssl_server_name on;
        proxy_ssl_name ${AUTH_SERVICE_HOST};
        proxy_set_header Host ${AUTH_SERVICE_HOST};
    }

    # Refresh, logout et autres routes auth
    location ~ ^/(api/v1/)?auth/ {
        limit_req zone=api burst=20 nodelay;
        limit_req_status 429;
        include /tmp/nginx/conf.d/proxy_params.conf;
        proxy_pass https://auth_service;
        proxy_ssl_server_name on;
        proxy_ssl_name ${AUTH_SERVICE_HOST};
        proxy_set_header Host ${AUTH_SERVICE_HOST};
    }

    # Profil utilisateur et administration
    # (/|$) pour capturer /users (liste admin) et /users/:id (détail)
    location ~ ^/(api/v1/)?users(/|$) {
        limit_req zone=api burst=20 nodelay;
        limit_req_status 429;
        include /tmp/nginx/conf.d/proxy_params.conf;
        proxy_pass https://auth_service;
        proxy_ssl_server_name on;
        proxy_ssl_name ${AUTH_SERVICE_HOST};
        proxy_set_header Host ${AUTH_SERVICE_HOST};
    }

    # ─────────────────────────────────────────────────────────────────
    # ORDER-SERVICE — /orders/*
    # Déclaré avant le fallback monolith pour intercepter les routes order.
    # Le suivi guest (POST /track-guest) a un rate limit plus strict.
    # ─────────────────────────────────────────────────────────────────

    location ~ ^/(api/v1/)?orders/track-guest {
        limit_req zone=auth burst=5 nodelay;
        limit_req_status 429;
        include /tmp/nginx/conf.d/proxy_params.conf;
        proxy_pass https://order_service;
        proxy_ssl_server_name on;
        proxy_ssl_name ${ORDER_SERVICE_HOST};
        proxy_set_header Host ${ORDER_SERVICE_HOST};
    }

    # (/|$) pour capturer /orders (liste) et /orders/:id (détail)
    location ~ ^/(api/v1/)?orders(/|$) {
        limit_req zone=order burst=20 nodelay;
        limit_req_status 429;
        include /tmp/nginx/conf.d/proxy_params.conf;
        proxy_pass https://order_service;
        proxy_ssl_server_name on;
        proxy_ssl_name ${ORDER_SERVICE_HOST};
        proxy_set_header Host ${ORDER_SERVICE_HOST};
    }

    # ─────────────────────────────────────────────────────────────────
    # ORDER-SERVICE (suite) — /shipping/*, /taxes/*
    #
    # Ces calculs appartiennent à l'order-service car shippingService et
    # taxService sont déjà utilisés en interne par ordersService#_calculateTotals.
    #
    # ORDRE : déclarés AVANT le fallback monolith pour éviter que les requêtes
    # tombent dans location / et retournent 404.
    # ─────────────────────────────────────────────────────────────────

    # Frais de port — calcul des options disponibles (public, guest compatible)
    location ~ ^/(api/v1/)?shipping/ {
        limit_req zone=api burst=20 nodelay;
        limit_req_status 429;
        include /tmp/nginx/conf.d/proxy_params.conf;
        proxy_pass https://order_service;
        proxy_ssl_server_name on;
        proxy_ssl_name ${ORDER_SERVICE_HOST};
        proxy_set_header Host ${ORDER_SERVICE_HOST};
    }

    # Taux de TVA et calculs fiscaux — données publiques (guest compatible)
    location ~ ^/(api/v1/)?taxes/ {
        limit_req zone=api burst=20 nodelay;
        limit_req_status 429;
        include /tmp/nginx/conf.d/proxy_params.conf;
        proxy_pass https://order_service;
        proxy_ssl_server_name on;
        proxy_ssl_name ${ORDER_SERVICE_HOST};
        proxy_set_header Host ${ORDER_SERVICE_HOST};
    }

    # ─────────────────────────────────────────────────────────────────
    # PRODUCT-SERVICE — /products/*, /categories/*, /promotions/*, /inventory/*
    # Déclaré avant le fallback monolith.
    # ─────────────────────────────────────────────────────────────────

    # (/|$) rend le slash final optionnel pour capturer :
    #   - les listes : /api/v1/products  (pas de slash)
    #   - les détails : /api/v1/products/seiko-5-sports  (avec slash)
    location ~ ^/(api/v1/)?(products|categories|promotions|inventory)(/|$) {
        limit_req zone=api burst=30 nodelay;
        limit_req_status 429;
        include /tmp/nginx/conf.d/proxy_params.conf;
        proxy_pass https://product_service;
        proxy_ssl_server_name on;
        proxy_ssl_name ${PRODUCT_SERVICE_HOST};
        proxy_set_header Host ${PRODUCT_SERVICE_HOST};
    }

    # ─────────────────────────────────────────────────────────────────
    # PAYMENT-SERVICE — /payments/*
    #
    # ORDRE DES ROUTES CRITIQUE :
    #   1. /webhook/stripe  → aucun rate limit (Stripe relance ses events)
    #   2. /create-session  → rate limit strict (anti-fraude, coût Stripe)
    #   3. /status          → rate limit modéré (polling post-redirection)
    #   4. /payments/       → fallback général (success, cancel)
    #
    # Le webhook Stripe est authentifié par signature HMAC côté service —
    # bloquer Stripe par rate limit casserait le flux de confirmation.
    # ─────────────────────────────────────────────────────────────────

    # Webhook Stripe — pas de rate limit, authentifié par signature HMAC.
    # proxy_params.conf n'est PAS inclus ici : il fixe proxy_read_timeout à 60s.
    # Stripe exige une réponse dans les 30s — on surcharge à 35s avec une marge.
    # Les autres directives de proxy_params sont inlinées explicitement.
    location ~ ^/(api/v1/)?payments/webhook/stripe {
        proxy_pass https://payment_service;
        proxy_ssl_server_name on;
        proxy_ssl_name ${PAYMENT_SERVICE_HOST};
        proxy_set_header Host              ${PAYMENT_SERVICE_HOST};
        proxy_set_header X-Real-IP         $remote_addr;
        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Request-ID      $request_id;
        proxy_connect_timeout  10s;
        proxy_send_timeout     60s;
        proxy_read_timeout     35s;
        proxy_http_version     1.1;
        proxy_set_header Connection "";
    }

    # Création de session Stripe — rate limit strict (zone=payment : 10r/min)
    location ~ ^/(api/v1/)?payments/create-session/ {
        limit_req zone=payment burst=5 nodelay;
        limit_req_status 429;
        include /tmp/nginx/conf.d/proxy_params.conf;
        proxy_pass https://payment_service;
        proxy_ssl_server_name on;
        proxy_ssl_name ${PAYMENT_SERVICE_HOST};
        proxy_set_header Host ${PAYMENT_SERVICE_HOST};
    }

    # Vérification du statut — rate limit modéré (polling légitime après redirection)
    location ~ ^/(api/v1/)?payments/status/ {
        limit_req zone=order burst=30 nodelay;
        limit_req_status 429;
        include /tmp/nginx/conf.d/proxy_params.conf;
        proxy_pass https://payment_service;
        proxy_ssl_server_name on;
        proxy_ssl_name ${PAYMENT_SERVICE_HOST};
        proxy_set_header Host ${PAYMENT_SERVICE_HOST};
    }

    # Toutes les autres routes payment (success, cancel, webhooks futurs...)
    location ~ ^/(api/v1/)?payments/ {
        limit_req zone=api burst=20 nodelay;
        limit_req_status 429;
        include /tmp/nginx/conf.d/proxy_params.conf;
        proxy_pass https://payment_service;
        proxy_ssl_server_name on;
        proxy_ssl_name ${PAYMENT_SERVICE_HOST};
        proxy_set_header Host ${PAYMENT_SERVICE_HOST};
    }

    # ─────────────────────────────────────────────────────────────────
    # CART-SERVICE — /cart/*
    #
    # Le panier est une route authentifiée avec des interactions UI fréquentes
    # (ajout/suppression à chaque clic). La zone=cart (120r/min) est calibrée
    # pour ne pas bloquer un utilisateur qui manipule son panier activement.
    #
    # Déclaré AVANT le fallback monolith — le monolith ne gère plus /cart/*.
    # ─────────────────────────────────────────────────────────────────

    location ~ ^/(api/v1/)?cart {
        limit_req zone=cart burst=20 nodelay;
        limit_req_status 429;
        include /tmp/nginx/conf.d/proxy_params.conf;
        proxy_pass https://cart_service;
        proxy_ssl_server_name on;
        proxy_ssl_name ${CART_SERVICE_HOST};
        proxy_set_header Host ${CART_SERVICE_HOST};
    }

    # ─────────────────────────────────────────────────────────────────
    # NOTIFICATION-SERVICE — aucune route publique
    #
    # Ce service est exclusivement appelé en interne (service-to-service).
    # Toute tentative d'accès public est explicitement rejetée ici
    # pour éviter le fallback silencieux vers le monolith.
    #
    # Les routes /internal/* sont déjà bloquées par le bloc global ci-dessus.
    # Ce bloc couvre les éventuelles tentatives sur /notifications/ ou /api/notification/.
    # ─────────────────────────────────────────────────────────────────

    location ~ ^/(api/v1/)?notifications/ {
        add_header Content-Type application/json always;
        return 403 '{"status":"fail","message":"Ce service est accessible en interne uniquement"}';
    }

    # ─────────────────────────────────────────────────────────────────
    # MONOLITHE — fallback
    # Tout ce qui ne correspond pas aux services ci-dessus :
    # admin, sitemap... (shipping et taxes → order-service)
    # ─────────────────────────────────────────────────────────────────
    location / {
        limit_req zone=api burst=20 nodelay;
        limit_req_status 429;
        include /tmp/nginx/conf.d/proxy_params.conf;
        proxy_pass https://monolith;
        proxy_ssl_server_name on;
        proxy_ssl_name ${MONOLITH_URL};
        proxy_set_header Host ${MONOLITH_URL};
    }
}